<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Linux上配置Jupyter Notebook远程访问]]></title>
    <url>%2F2018%2F11%2F05%2FLinux%E4%B8%8A%E9%85%8D%E7%BD%AEJupyter%20Notebook%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE%2F</url>
    <content type="text"><![CDATA[导语：在做大数据量的特征工程以及数据建模的时候，由于个人电脑内存较小，我们往往需要借助于一台内存足够大的Linux服务器。在Linux服务器上配置Jupyter Notebook的远程访问，能够方便我们在本地直接通过浏览器远程使用服务器。 Jupyter NotebookJupyter Notebook 的本质是一个 Web 应用程序，便于创建和共享文学化程序文档，支持实时代码，数学方程，可视化和 markdown。 用途包括：数据清理和转换，数值模拟，统计建模，机器学习等等。 Linux上修改Jupyter配置文件1.生成Jupyter配置文件$ /root/.jupyter/jupyter_notebook_config.py #/root/是服务器的根目录 2.生成密码$ ipython 进入python命令编辑界面 In [1]: from notebook.auth import passwd In [2]: passwd() Enter password: #输入你的密码 Verify password: #再次输入你的密码 Out[2]:&#39;sha1:sdjh2yu3h2g27y4efuhf2h&#39; #你的密码生成的哈希值，复制它 3.修改Jupyter默认配置文件$ gedit /root/.jupyter/jupyter_notebook_config.py 打开之后，修改一下几项，注意去掉前面的注释符号‘#’ c.NotebookApp.ip=&#39;*&#39; # &#39;*&#39;表示所有ip都可以访问 c.NotebookApp.password=u&#39;sha1:sdjh2yu3h2g27y4efuhf2h&#39; #粘贴上一步骤中的哈希值 c.NotebookApp.open_browser=False c.NotebookApp.port=9999 #指定访问的端口号 4.启动Jupyter Notebook$ Jupyter Notebook 本地访问打开浏览器，输入 http://服务器ip地址：端口号 即可如果遇到jupyter SSL Error 问题，则可能是SSL协议不对，改成https即可]]></content>
      <categories>
        <category>Jupyter配置</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[FM(Factorization Machine)模型]]></title>
    <url>%2F2018%2F10%2F18%2FFM(Factorization%20Machine)%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[导语：FM是由Steffen Rendle于2010年提出的一种基于矩阵分解的机器学习模型，解决了CTR预估任务中稀疏数据的特征组合问题，在推荐和计算广告领域中得到广泛应用。本文将从背景、原理以及基于TensorFlow的代码实现三方面详细介绍FM模型。 1.FM的背景在CTR预估的问题中存在大量的Categorical特征，我们通常的处理方法是对Categorical特征进行one-hot编码处理成0-1的二值特征，以保证不同Categorical特征之间的距离一致。形如：可以看出，特征不同的取值个数决定了one-hot编码之后特征维度，并且其中只有1维特征是1，其余的都是0。所以one-hot编码会使得特征变得高维并且稀疏，很难进行特征组合得到高阶的交叉特征。那为什么要进行特征组合呢？实际上，大量的特征之间存在潜在的关联。举个简单例子，女性用户倾向于点击化妆品、服装类型的物品，而男性用户则倾向于点击运动、电子类的物品，所以相比一阶特征，性别交叉物品种类的二阶特征会对CTR预估有更重要的作用。 2.FM的原理一般的线性模型 没有考虑特征组合，FM模型在线性模型的基础上增加二阶交叉特征，模型如下：然而针对大规模的稀疏数据，这样的模型还存在一些问题。从模型的表达式可以看出，$x_i\cdot x_j$是两个不同特征向量的内积，只有当$x_i$和$x_j$都不为0时内积才有意义，所以大量的稀疏数据会导致模型计算复杂度过高，很难训练得到$w_{i,j}$。为了得到$w_{i,j}$，FM利用矩阵分解的思想，将交叉项系数矩阵W分解成两个低秩矩阵：$W=VV^T$$w_{i,j} = v_i v_{j}`{T}$，所以二阶交叉特征部分变形为：由于必须将$x_i\cdot x_j$分开才能有效地利用稀疏数据，所以FM对表达式做了进一步的化简：这步化简如何来的呢？其实不难发现等式的左边就是n*n阶对称矩阵的上三角部分，它的面积恰好等于矩形减掉对角线之后的一半。由于$\left&lt; v_i,v_j \right&gt;$等于$\sum_{f=1}^{k}v_{i,f}v_{j,f}$，所以展开后公式为：FM的表达式经过变形之后，所有包含非零$x_i$的组合样本都可以用来学习$v_i$,这在很大程度上避免了数据稀疏造成参数估计不准确的影响。用梯度下降法进行模型训练时需要求预测值y_对各个参数的偏导数：模型的参数从$\frac{n(n-1)}{2}$减少为nk+n+1，模型的计算复杂度从$O \left( n^{2} \right)$降低到$O \left( nk \right)$，综上FM是一个针对大规模稀疏数据的高效预测模型。 3.基于TensorFlow的FM实现123456789101112131415161718192021222324252627282930class FM(Model): def __init__(self,input_dim=None,output_dim=1,factor_orider=10,opt_algo='gd',learning_rate=le-2,l2_w=0,l2_v=0,random_seed=23): Model.__init__(self) #定义计算图 self.graph = tf.Graph() with self.graph.as_default(): if random_seed is not None: tf.set_random_seed(random_seed) #定义参数节点 self.X = tf.sparse_placeholder(tf.float32, shape=[None, input_dim], name="X") self.y = tf.placeholder(tf.float32, shape=[None, output_dim], name="y") elf.V = tf.get_variable("v", shape=[input_dim, factor_orider], dtype=tf.float32, initializer=tf.truncated_normal_initializer(stddev=0.3)) self.W = tf.get_variable("Weights", shape=[n, 1], dtype=tf.float32, initializer=tf.truncated_normal_initializer(stddev=0.3)) self.b = tf.get_variable("Biases", shape=[1, 1], dtype=tf.float32, initializer=tf.zeros_initializer()) #定义模型 #一阶部分 xw = tf.sparse_tensor_dense_matmul(self.X, self.W) #二阶部分 multiply是矩阵对应元素相乘，matmul是矩阵乘法 fm_hat = tf.reduce_sum(tf.square(tf.sparse_tensor_dense_matmul(self.X ,self.V)) - (tf.sparse_tensor_dense_matmul(tf.multiply(self.X,self.X), tf.multiply(self.V,self.V))), axis=1, keep_dims=True) / 2 #fm函数 logits = tf.reshape(b+xw+fm_hat,[-1]) #通过sigmoid函数计算预测值 self.y_ = tf.sigmoid(logits) #模型的损失函数：交叉熵损失函数l2正则 self.loss = tf.reduce_mean(tf.nn.sigmoid_cross_entropy_with_logits(logits=logits, labels=self.y)) +l2_w * tf.nn.l2_loss(xw) + l2_v * tf.nn.l2_loss(xv) #模型的优化器 self.optimizer = get_optimizer(opt_algo, learning_rate, self.loss) #初始化模型参数 with tf.Session() as sess: sess.run(tf.global_variables_initializer())]]></content>
      <categories>
        <category>推荐与CTR</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hexo+Github配置个人博客]]></title>
    <url>%2F2017%2F09%2F02%2FHexo%2BGithub%E9%85%8D%E7%BD%AE%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[导语：Hexo+Github是利用Hexo框架迅速创建博客网站，并将网站代码托管到GitHub上的一种方式，具有开源、优雅、高效等特点。本文主要记录使用Hexo+Github配置个人博客的过程，包括安装、部署、使用以及美化。 Hexo与GitHubHexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。GitHub的作用类似于网站的服务器，我们将Hexo生成的静态网页部署到GitHub上，GitHub会提供一个username.github.io作为个人博客的地址。 安装Hexo1.安装Node.jshttps://nodejs.org/ 2.安装Githttps://git-scm.com/downloads 3.安装Hexocmd输入： $ npm install -g hexo-cli Hexo建站1.初始化站点Git Bash输入： $ hexo init &lt;folder&gt; //folder为自定义的文件夹名 $ cd &lt;folder&gt; $ npm install 初始化完成后,根目录的文件如下： _config.yml博客的配置主文件，网站的主要参数在这里配置，比如网站名称，副标题，描述，作者，语言，主题，部署等等。详细说明见：https://hexo.io/zh-cn/docs/configuration package.json记录hexo框架的参数和所依赖插件 scaffolds页面模板文件存放目录，新建文章时，Hexo 会根据 scaffold 来建立文件 source保存文章的目录，文章是.md文件，Hexo会将_post目录下的.md文件编译成html文件，存放到根目录的public文件夹下 themes主题文件存放目录，Hexo中集成了丰富的博客主题，用户可以自己下载并更换 public网页文件的存放目录，网页文件是使用命令自动生成的，部署博客时Hexo会将public下的文件上传至GitHub 2.本地访问Git Bash输入： $ hexo server //使用默认端口4000 或者 $hexo server -p 5000 //更改端口 本地浏览器输入： http://localhost:4000/ 3.部署到GitHub上在Github上new repositories，并且Repository name为[username].github.io，[username]指的是github用户名。修改根目录下的_config.yml配置文件,注意冒号后面必须有一个空格 deploy: type: git repository: https://github.com/[username]/[username].github.io.git branch: master 安装部署git的依赖包，根目录下cmd输入： npm install hexo-deployer-git --save 生成页面并部署至GitHub，Git Bash输入： hexo generate //hexo g hexo deploy //hexo d 浏览器访问[username].github.io即可 常用命令hexo clean //清除缓存 hexo g //保存修改，生成文件 hexo s 或 hexo s -p 指定端口//启动本地服务，可进行本地预览 hexo d //发布到远程GitHub 上述命令是把public文件夹下的网站页面上传至GitHub,我们还可以使用Git命令将项目的所有代码保存到GitHub上： git add . //将项目的所有文件添加到仓库中 git status //查看更改的内容 git commit -m &quot;版本信息&quot; //为更新做注释 git pull origin hexo //多人协作时，代码上传github前需要pull远程仓库代码到本地 git push origin hexo //上传代码到GitHub远程仓库的hexo分支 Hexo页面美化下载主题Hexo主题官网中提供了丰富的主题模板，我们可以从中选择自己喜欢的主题进行配置，我的个人博客选择的是NexT主题，安装步骤如下：站点根目录下Git Bash输入如下命令，完成后，在根目录的themes文件夹下会增加一个next的目录，里面存放next主题的相关文件 $ git clone https://github.com/iissnan/hexo-theme-next themes/next 在根目录的_config.yml配置文件中启用next主题 theme: next 重新部署网站即可生效。可以通过修改next文件夹下的_config.yml来改变next主题样式，如： #scheme: Muse #scheme: Mist scheme: Pisces 给文章添加分类和标签创建categories和tags页面 $ hexo new page categories $ hexo new page tags 创建完成后，在source文件夹下会增加categories和tags两个文件夹，分别打开这两个文件夹下的index.md修改： --- title: 文章分类 date: 2018-00-00 13:47:40 type: &quot;categories&quot; --- --- title: 标签 date: 2018-00-00 13:47:40 type: &quot;tags&quot; --- 在文章的.md头部属性中增加categories和tags属性： --- title: FM(Factorization Machine)模型 date: 2018-10-18 categories: - 推荐与CTR tags: - 矩阵分解 - CTR预估 --- 给文章插入图片安装依赖包： npm install hexo-asset-image --save source目录下建立images文件夹用于存放图片，文章中插入图片： ![图片说明文字](图片的相对路径) 使用LaTex编辑数学公式更换依赖包，cmd输入： npm uninstall hexo-renderer-marked --save npm install hexo-renderer-kramed --save 修改/node_modules/hexo-renderer-kramed/lib/renderer.js： // Change inline math rule function formatText(text) { return text; } 更换依赖包，cmd输入： npm uninstall hexo-math --save npm install hexo-renderer-mathjax --save 修改Mathjax的配置文件/node_modules/hexo-renderer-mathjax/mathjax.html： &lt;!-- &lt;script src=&quot;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot;&gt;&lt;/script&gt; --&gt; &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML&quot;&gt;&lt;/script&gt; 更改默认转义规则/node_modules\kramed\lib\rules\inline.js： //escape: /^\\([\\`*{}\[\]()#$+\-.!_&gt;])/, //em: /^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/, escape: /^\\([`*\[\]()# +\-.!_&gt;])/, em: /^\*((?:\*\*|[\s\S])+?)\*(?!\*)/, 在next目录的_config.yml中开启mathjax mathjax: enable: true 文章的.md头部属性中增加mathjax属性： --- title: FM(Factorization Machine)模型 date: 2018-10-18 categories: - 推荐与CTR mathjax: true --- 给文章添加阅读次数注册LeanClound账号，创建一个应用：进入应用中创建一个名为Counter的Class:在next目录的_config.yml中增加： leancloud_visitors: enable: true app_id: app_key: app_id和app_key的值来源于下图： 博客添加站内搜索安装站内搜索插件 $ npm install hexo-generator-searchdb --save 根目录下的_config.yml添加： #表示站内搜索 search: path: search.xml field: post format: html limit: 10000 next目录下的_config.yml添加： local_search: enable: true #设置为true trigger: auto # auto / manual，auto 自动搜索、manual：按回车[enter ]键手动搜索 top_n_per_article: 1 unescape: true]]></content>
      <categories>
        <category>Hexo配置</category>
      </categories>
  </entry>
</search>
