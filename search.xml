<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[FM(Factorization Machine)模型]]></title>
    <url>%2F2018%2F10%2F18%2FFM(Factorization%20Machine)%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[导语：FM是由Steffen Rendle于2010年提出的一种基于矩阵分解的机器学习模型，解决了CTR预估任务中稀疏数据的特征组合问题，在推荐和计算广告领域中得到广泛应用。本文将从背景、原理以及基于TensorFlow的代码实现三方面详细介绍FM模型。 1.FM的背景在CTR预估的问题中存在大量的Categorical特征，我们通常的处理方法是对Categorical特征进行one-hot编码处理成0-1的二值特征，以保证不同Categorical特征之间的距离一致。形如：可以看出，特征不同的取值个数决定了one-hot编码之后特征维度，并且其中只有1维特征是1，其余的都是0。所以one-hot编码会使得特征变得高维并且稀疏，很难进行特征组合得到高阶的交叉特征。那为什么要进行特征组合呢？实际上，大量的特征之间存在潜在的关联。举个简单例子，女性用户倾向于点击化妆品、服装类型的物品，而男性用户则倾向于点击运动、电子类的物品，所以相比一阶特征，性别交叉物品种类的二阶特征会对CTR预估有更重要的作用。 2.FM的原理一般的线性模型 没有考虑特征组合，FM模型在线性模型的基础上增加二阶交叉特征，模型如下：然而针对大规模的稀疏数据，这样的模型还存在一些问题。从模型的表达式可以看出，$x_i\cdot x_j$是两个不同特征向量的内积，只有当$x_i$和$x_j$都不为0时内积才有意义，所以大量的稀疏数据会导致模型计算复杂度过高，很难训练得到$w_{i,j}$。为了得到$w_{i,j}$，FM利用矩阵分解的思想，将交叉项系数矩阵W分解成两个低秩矩阵：$W=VV^T$$w_{i,j} = v_i v_{j}`{T}$，所以二阶交叉特征部分变形为：由于必须将$x_i\cdot x_j$分开才能有效地利用稀疏数据，所以FM对表达式做了进一步的化简：这步化简如何来的呢？其实不难发现等式的左边就是n*n阶对称矩阵的上三角部分，它的面积恰好等于矩形减掉对角线之后的一半。由于$\left&lt; v_i,v_j \right&gt;$等于$\sum_{f=1}^{k}v_{i,f}v_{j,f}$，所以展开后公式为：FM的表达式经过变形之后，所有包含非零$x_i$的组合样本都可以用来学习$v_i$,这在很大程度上避免了数据稀疏造成参数估计不准确的影响。用梯度下降法进行模型训练时需要求预测值y_对各个参数的偏导数：模型的参数从$\frac{n(n-1)}{2}$减少为nk+n+1，模型的计算复杂度从$O \left( n^{2} \right)$降低到$O \left( nk \right)$，综上FM是一个针对大规模稀疏数据的高效预测模型。 3.基于TensorFlow的FM实现123456789101112131415161718192021222324252627282930class FM(Model): def __init__(self,input_dim=None,output_dim=1,factor_orider=10,opt_algo='gd',learning_rate=le-2,l2_w=0,l2_v=0,random_seed=23): Model.__init__(self) #定义计算图 self.graph = tf.Graph() with self.graph.as_default(): if random_seed is not None: tf.set_random_seed(random_seed) #定义参数节点 self.X = tf.sparse_placeholder(tf.float32, shape=[None, input_dim], name="X") self.y = tf.placeholder(tf.float32, shape=[None, output_dim], name="y") elf.V = tf.get_variable("v", shape=[input_dim, factor_orider], dtype=tf.float32, initializer=tf.truncated_normal_initializer(stddev=0.3)) self.W = tf.get_variable("Weights", shape=[n, 1], dtype=tf.float32, initializer=tf.truncated_normal_initializer(stddev=0.3)) self.b = tf.get_variable("Biases", shape=[1, 1], dtype=tf.float32, initializer=tf.zeros_initializer()) #定义模型 #一阶部分 xw = tf.sparse_tensor_dense_matmul(self.X, self.W) #二阶部分 multiply是矩阵对应元素相乘，matmul是矩阵乘法 fm_hat = tf.reduce_sum(tf.square(tf.sparse_tensor_dense_matmul(self.X ,self.V)) - (tf.sparse_tensor_dense_matmul(tf.multiply(self.X,self.X), tf.multiply(self.V,self.V))), axis=1, keep_dims=True) / 2 #fm函数 logits = tf.reshape(b+xw+fm_hat,[-1]) #通过sigmoid函数计算预测值 self.y_ = tf.sigmoid(logits) #模型的损失函数：交叉熵损失函数l2正则 self.loss = tf.reduce_mean(tf.nn.sigmoid_cross_entropy_with_logits(logits=logits, labels=self.y)) +l2_w * tf.nn.l2_loss(xw) + l2_v * tf.nn.l2_loss(xv) #模型的优化器 self.optimizer = get_optimizer(opt_algo, learning_rate, self.loss) #初始化模型参数 with tf.Session() as sess: sess.run(tf.global_variables_initializer())]]></content>
      <categories>
        <category>推荐与CTR</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[欢迎使用Markdown编辑器写博客]]></title>
    <url>%2F2017%2F09%2F20%2F%E6%AC%A2%E8%BF%8E%E4%BD%BF%E7%94%A8markdown%E7%BC%96%E8%BE%91%E5%99%A8%2F</url>
    <content type="text"><![CDATA[本Markdown编辑器使用StackEdit修改而来，用它写博客，将会带来全新的体验哦： Markdown和扩展Markdown简洁的语法 代码块高亮 图片链接和图片上传 LaTex数学公式 UML序列图和流程图 离线写博客 导入导出Markdown文件 丰富的快捷键 快捷键 加粗 Ctrl + B 斜体 Ctrl + I 引用 Ctrl + Q 插入链接 Ctrl + L 插入代码 Ctrl + K 插入图片 Ctrl + G 提升标题 Ctrl + H 有序列表 Ctrl + O 无序列表 Ctrl + U 横线 Ctrl + R 撤销 Ctrl + Z 重做 Ctrl + Y Markdown及扩展 Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。 —— [ 维基百科 ] 使用简单的符号标识不同的标题，将某些文字标记为粗体或者斜体，创建一个链接等，详细语法参考帮助？。 本编辑器支持 Markdown Extra , 扩展了很多好用的功能。具体请参考Github. 表格Markdown Extra 表格语法： 项目 价格 Computer $1600 Phone $12 Pipe $1 可以使用冒号来定义对齐方式： 项目 价格 数量 Computer 1600 元 5 Phone 12 元 12 Pipe 1 元 234 定义列表Markdown Extra 定义列表语法：项目１项目２: 定义 A: 定义 B 项目３: 定义 C : 定义 D &gt; 定义D内容 代码块代码块语法遵循标准markdown代码，例如：12345678910@requires_authorizationdef somefunc(param1='', param2=0): '''A docstring''' if param1 &gt; param2: # interesting print 'Greater' return (param2 - param1 + 1) or Noneclass SomeClass: pass&gt;&gt;&gt; message = '''interpreter... prompt''' 脚注生成一个脚注footnote. footnote: 这里是 脚注 的 内容. 目录用 [TOC]来生成目录： [TOC] 数学公式使用MathJax渲染LaTex 数学公式，详见math.stackexchange.com. 行内公式，数学公式为：$\Gamma(n) = (n-1)!\quad\forall n\in\mathbb N$。 块级公式： x = \dfrac{-b \pm \sqrt{b^2 - 4ac}}{2a}更多LaTex语法请参考 这儿. UML 图:可以渲染序列图： 123张三-&gt;李四: 嘿，小四儿, 写博客了没?Note right of 李四: 李四愣了一下，说：李四--&gt;张三: 忙得吐血，哪有时间写。 或者流程图： 12345678st=&gt;start: 开始e=&gt;end: 结束op=&gt;operation: 我的操作cond=&gt;condition: 确认？st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 关于 序列图 语法，参考 这儿, 关于 流程图 语法，参考 这儿. 离线写博客即使用户在没有网络的情况下，也可以通过本编辑器离线写博客（直接在曾经使用过的浏览器中输入write.blog.csdn.net/mdeditor即可。Markdown编辑器使用浏览器离线存储将内容保存在本地。 用户写博客的过程中，内容实时保存在浏览器缓存中，在用户关闭浏览器或者其它异常情况下，内容不会丢失。用户再次打开浏览器时，会显示上次用户正在编辑的没有发表的内容。 博客发表后，本地缓存将被删除。 用户可以选择 把正在写的博客保存到服务器草稿箱，即使换浏览器或者清除缓存，内容也不会丢失。 注意：虽然浏览器存储大部分时候都比较可靠，但为了您的数据安全，在联网后，请务必及时发表或者保存到服务器草稿箱。 浏览器兼容 目前，本编辑器对Chrome浏览器支持最为完整。建议大家使用较新版本的Chrome。 IE９以下不支持 IE９，１０，１１存在以下问题 不支持离线功能 IE9不支持文件导入导出 IE10不支持拖拽文件导入]]></content>
      <categories>
        <category>Markdown教程</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+Github配置个人博客]]></title>
    <url>%2F2017%2F09%2F02%2FHexo%2BGithub%E9%85%8D%E7%BD%AE%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[导语：Hexo+Github是利用Hexo框架迅速创建博客网站，并将网站代码托管到GitHub上的一种方式，具有开源、优雅、高效等特点。本文主要记录使用Hexo+Github配置个人博客的过程，包括安装、部署、使用以及美化。 Hexo与GitHubHexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。GitHub的作用类似于网站的服务器，我们将Hexo生成的静态网页部署到GitHub上，GitHub会提供一个username.github.io作为个人博客的地址。 安装Hexo1.安装Node.jshttps://nodejs.org/ 2.安装Githttps://git-scm.com/downloads 3.安装Hexocmd输入： $ npm install -g hexo-cli Hexo建站1.初始化站点Git Bash输入： $ hexo init &lt;folder&gt; //folder为自定义的文件夹名 $ cd &lt;folder&gt; $ npm install 初始化完成后,根目录的文件如下： _config.yml博客的配置主文件，网站的主要参数在这里配置，比如网站名称，副标题，描述，作者，语言，主题，部署等等。详细说明见：https://hexo.io/zh-cn/docs/configuration package.json记录hexo框架的参数和所依赖插件 scaffolds页面模板文件存放目录，新建文章时，Hexo 会根据 scaffold 来建立文件 source保存文章的目录，文章是.md文件，Hexo会将_post目录下的.md文件编译成html文件，存放到根目录的public文件夹下 themes主题文件存放目录，Hexo中集成了丰富的博客主题，用户可以自己下载并更换 public网页文件的存放目录，网页文件是使用命令自动生成的，部署博客时Hexo会将public下的文件上传至GitHub 2.本地访问Git Bash输入： $ hexo server //使用默认端口4000 或者 $hexo server -p 5000 //更改端口 本地浏览器输入： http://localhost:4000/ 3.部署到GitHub上在Github上new repositories，并且Repository name为[username].github.io，[username]指的是github用户名。修改根目录下的_config.yml配置文件,注意冒号后面必须有一个空格 deploy: type: git repository: https://github.com/[username]/[username].github.io.git branch: master 安装部署git的依赖包，根目录下cmd输入： npm install hexo-deployer-git --save 生成页面并部署至GitHub，Git Bash输入： hexo generate //hexo g hexo deploy //hexo d 浏览器访问[username].github.io即可 常用命令hexo clean //清除缓存 hexo g //保存修改，生成文件 hexo s 或 hexo s -p 指定端口//启动本地服务，可进行本地预览 hexo d //发布到远程GitHub 上述命令是把public文件夹下的网站页面上传至GitHub,我们还可以使用Git命令将项目的所有代码保存到GitHub上： git add . //将项目的所有文件添加到仓库中 git status //查看更改的内容 git commit -m &quot;版本信息&quot; //为更新做注释 git pull origin hexo //多人协作时，代码上传github前需要pull远程仓库代码到本地 git push origin hexo //上传代码到GitHub远程仓库的hexo分支 Hexo页面美化下载主题Hexo主题官网中提供了丰富的主题模板，我们可以从中选择自己喜欢的主题进行配置，我的个人博客选择的是NexT主题，安装步骤如下：站点根目录下Git Bash输入如下命令，完成后，在根目录的themes文件夹下会增加一个next的目录，里面存放next主题的相关文件 $ git clone https://github.com/iissnan/hexo-theme-next themes/next 在根目录的_config.yml配置文件中启用next主题 theme: next 重新部署网站即可生效。可以通过修改next文件夹下的_config.yml来改变next主题样式，如： #scheme: Muse #scheme: Mist scheme: Pisces 给文章添加分类和标签创建categories和tags页面 $ hexo new page categories $ hexo new page tags 创建完成后，在source文件夹下会增加categories和tags两个文件夹，分别打开这两个文件夹下的index.md修改： --- title: 文章分类 date: 2018-00-00 13:47:40 type: &quot;categories&quot; --- --- title: 标签 date: 2018-00-00 13:47:40 type: &quot;tags&quot; --- 在文章的.md头部属性中增加categories和tags属性： --- title: FM(Factorization Machine)模型 date: 2018-10-18 categories: - 推荐与CTR tags: - 矩阵分解 - CTR预估 --- 给文章插入图片安装依赖包： npm install hexo-asset-image --save source目录下建立images文件夹用于存放图片，文章中插入图片： ![图片说明文字](图片的相对路径) 使用LaTex编辑数学公式更换依赖包，cmd输入： npm uninstall hexo-renderer-marked --save npm install hexo-renderer-kramed --save 修改/node_modules/hexo-renderer-kramed/lib/renderer.js： // Change inline math rule function formatText(text) { return text; } 更换依赖包，cmd输入： npm uninstall hexo-math --save npm install hexo-renderer-mathjax --save 修改Mathjax的配置文件/node_modules/hexo-renderer-mathjax/mathjax.html： &lt;!-- &lt;script src=&quot;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot;&gt;&lt;/script&gt; --&gt; &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML&quot;&gt;&lt;/script&gt; 更改默认转义规则/node_modules\kramed\lib\rules\inline.js： //escape: /^\\([\\`*{}\[\]()#$+\-.!_&gt;])/, //em: /^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/, escape: /^\\([`*\[\]()# +\-.!_&gt;])/, em: /^\*((?:\*\*|[\s\S])+?)\*(?!\*)/, 在next目录的_config.yml中开启mathjax mathjax: enable: true 文章的.md头部属性中增加mathjax属性： --- title: FM(Factorization Machine)模型 date: 2018-10-18 categories: - 推荐与CTR mathjax: true --- 给文章添加阅读次数注册LeanClound账号，创建一个应用：进入应用中创建一个名为Counter的Class:在next目录的_config.yml中增加： leancloud_visitors: enable: true app_id: app_key: app_id和app_key的值来源于下图： 博客添加站内搜索安装站内搜索插件 $ npm install hexo-generator-searchdb --save 根目录下的_config.yml添加： #表示站内搜索 search: path: search.xml field: post format: html limit: 10000 next目录下的_config.yml添加： local_search: enable: true #设置为true trigger: auto # auto / manual，auto 自动搜索、manual：按回车[enter ]键手动搜索 top_n_per_article: 1 unescape: true]]></content>
      <categories>
        <category>Hexo配置</category>
      </categories>
  </entry>
</search>
