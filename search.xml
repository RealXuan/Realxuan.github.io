<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>FM(Factorization Machine)模型</title>
      <link href="/2018/10/18/FM(Factorization%20Machine)%E6%A8%A1%E5%9E%8B/"/>
      <url>/2018/10/18/FM(Factorization%20Machine)%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>导语：FM是由Steffen Rendle于2010年提出的一种基于矩阵分解的机器学习模型，解决了CTR预估任务中稀疏数据的特征组合问题，在推荐和计算广告领域中得到广泛应用。本文将从背景、原理以及基于TensorFlow的代码实现三方面详细介绍FM模型。</p></blockquote><h2 id="1-FM的背景"><a href="#1-FM的背景" class="headerlink" title="1.FM的背景"></a>1.FM的背景</h2><p>在CTR预估的问题中存在大量的Categorical特征，我们通常的处理方法是对Categorical特征进行one-hot编码处理成0-1的二值特征，以保证不同Categorical特征之间的距离一致。形如：<br><img src="/images/1018_pic1.PNG" alt="upload successful"><br>可以看出，特征不同的取值个数决定了one-hot编码之后特征维度，并且其中只有1维特征是1，其余的都是0。所以one-hot编码会使得特征变得高维并且稀疏，很难进行特征组合得到高阶的交叉特征。那为什么要进行特征组合呢？实际上，大量的特征之间存在潜在的关联。举个简单例子，女性用户倾向于点击化妆品、服装类型的物品，而男性用户则倾向于点击运动、电子类的物品，所以相比一阶特征，性别交叉物品种类的二阶特征会对CTR预估有更重要的作用。</p><a id="more"></a><h2 id="2-FM的原理"><a href="#2-FM的原理" class="headerlink" title="2.FM的原理"></a>2.FM的原理</h2><p>一般的线性模型 没有考虑特征组合，FM模型在线性模型的基础上增加二阶交叉特征，模型如下：<br><img src="/images/1019_pic1.PNG" alt="upload successful"><br>然而针对大规模的稀疏数据，这样的模型还存在一些问题。从模型的表达式可以看出，$x_i\cdot x_j$是两个不同特征向量的内积，只有当$x_i$和$x_j$都不为0时内积才有意义，所以大量的稀疏数据会导致模型计算复杂度过高，很难训练得到$w_{i,j}$。<br>为了得到$w_{i,j}$，FM利用矩阵分解的思想，将交叉项系数矩阵W分解成两个低秩矩阵：$W=VV^T$<br><img src="/images/1019_pic2.PNG" alt="upload successful"><br>$w_{i,j} = v_i v_{j}`{T}$，所以二阶交叉特征部分变形为：<br><img src="/images/1019_pic3.PNG" alt="upload successful"><br>由于必须将$x_i\cdot x_j$分开才能有效地利用稀疏数据，所以FM对表达式做了进一步的化简：<br><img src="/images/1019_pic4.PNG" alt="upload successful"><br>这步化简如何来的呢？其实不难发现等式的左边就是n*n阶对称矩阵的上三角部分，它的面积恰好等于矩形减掉对角线之后的一半。<br><img src="/images/1019_pic5.PNG" alt="upload successful"><br>由于$\left&lt; v_i,v_j \right&gt;$等于$\sum_{f=1}^{k}v_{i,f}v_{j,f}$，所以展开后公式为：<br><img src="/images/1019_pic6.PNG" alt="upload successful"><br>FM的表达式经过变形之后，所有包含非零$x_i$的组合样本都可以用来学习$v_i$,这在很大程度上避免了数据稀疏造成参数估计不准确的影响。<br>用梯度下降法进行模型训练时需要求预测值y_对各个参数的偏导数：<br><img src="/images/1019_pic7.PNG" alt="upload successful"><br>模型的参数从$\frac{n(n-1)}{2}$减少为nk+n+1，模型的计算复杂度从$O \left( n^{2} \right)$降低到$O \left( nk \right)$，综上FM是一个针对大规模稀疏数据的高效预测模型。</p><h2 id="3-基于TensorFlow的FM实现"><a href="#3-基于TensorFlow的FM实现" class="headerlink" title="3.基于TensorFlow的FM实现"></a>3.基于TensorFlow的FM实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">FM</span><span class="params">(Model)</span>:</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,input_dim=None,output_dim=<span class="number">1</span>,factor_orider=<span class="number">10</span>,opt_algo=<span class="string">'gd'</span>,learning_rate=le<span class="number">-2</span>,l2_w=<span class="number">0</span>,l2_v=<span class="number">0</span>,random_seed=<span class="number">23</span>)</span>:</span></div><div class="line">Model.__init__(self)</div><div class="line">    <span class="comment">#定义计算图</span></div><div class="line">self.graph = tf.Graph()</div><div class="line"> <span class="keyword">with</span> self.graph.as_default():</div><div class="line"><span class="keyword">if</span> random_seed <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">tf.set_random_seed(random_seed)</div><div class="line"><span class="comment">#定义参数节点</span></div><div class="line">self.X = tf.sparse_placeholder(tf.float32, shape=[<span class="keyword">None</span>, input_dim], name=<span class="string">"X"</span>)</div><div class="line">self.y = tf.placeholder(tf.float32, shape=[<span class="keyword">None</span>, output_dim], name=<span class="string">"y"</span>)</div><div class="line">elf.V = tf.get_variable(<span class="string">"v"</span>, shape=[input_dim, factor_orider], dtype=tf.float32, initializer=tf.truncated_normal_initializer(stddev=<span class="number">0.3</span>))</div><div class="line">self.W = tf.get_variable(<span class="string">"Weights"</span>, shape=[n, <span class="number">1</span>], dtype=tf.float32, initializer=tf.truncated_normal_initializer(stddev=<span class="number">0.3</span>))</div><div class="line">self.b = tf.get_variable(<span class="string">"Biases"</span>, shape=[<span class="number">1</span>, <span class="number">1</span>], dtype=tf.float32, initializer=tf.zeros_initializer())</div><div class="line"><span class="comment">#定义模型</span></div><div class="line"><span class="comment">#一阶部分</span></div><div class="line"> xw = tf.sparse_tensor_dense_matmul(self.X, self.W)</div><div class="line"><span class="comment">#二阶部分 multiply是矩阵对应元素相乘，matmul是矩阵乘法</span></div><div class="line">fm_hat = tf.reduce_sum(tf.square(tf.sparse_tensor_dense_matmul(self.X ,self.V)) - (tf.sparse_tensor_dense_matmul(tf.multiply(self.X,self.X), tf.multiply(self.V,self.V))), axis=<span class="number">1</span>, keep_dims=<span class="keyword">True</span>) / <span class="number">2</span></div><div class="line"><span class="comment">#fm函数</span></div><div class="line">logits = tf.reshape(b+xw+fm_hat,[<span class="number">-1</span>])</div><div class="line"><span class="comment">#通过sigmoid函数计算预测值</span></div><div class="line">self.y_ = tf.sigmoid(logits)</div><div class="line"><span class="comment">#模型的损失函数：交叉熵损失函数l2正则</span></div><div class="line">self.loss = tf.reduce_mean(tf.nn.sigmoid_cross_entropy_with_logits(logits=logits, labels=self.y)) +l2_w * tf.nn.l2_loss(xw) + l2_v * tf.nn.l2_loss(xv)</div><div class="line"><span class="comment">#模型的优化器</span></div><div class="line">self.optimizer = get_optimizer(opt_algo, learning_rate, self.loss)</div><div class="line"><span class="comment">#初始化模型参数</span></div><div class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</div><div class="line">sess.run(tf.global_variables_initializer())</div></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 推荐与CTR </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Hexo+Github配置个人博客</title>
      <link href="/2017/09/02/Hexo+Github%E9%85%8D%E7%BD%AE%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2017/09/02/Hexo+Github%E9%85%8D%E7%BD%AE%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>导语：Hexo+Github是利用Hexo框架迅速创建博客网站，并将网站代码托管到GitHub上的一种方式，具有开源、优雅、高效等特点。本文主要记录使用Hexo+Github配置个人博客的过程，包括安装、部署、使用以及美化。</p></blockquote><h2 id="Hexo与GitHub"><a href="#Hexo与GitHub" class="headerlink" title="Hexo与GitHub"></a>Hexo与GitHub</h2><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。GitHub的作用类似于网站的服务器，我们将Hexo生成的静态网页部署到GitHub上，GitHub会提供一个username.github.io作为个人博客的地址。</p><h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><h3 id="1-安装Node-js"><a href="#1-安装Node-js" class="headerlink" title="1.安装Node.js"></a>1.安装Node.js</h3><p><a href="https://nodejs.org/" target="_blank" rel="external">https://nodejs.org/</a></p><h3 id="2-安装Git"><a href="#2-安装Git" class="headerlink" title="2.安装Git"></a>2.安装Git</h3><p><a href="https://git-scm.com/downloads" target="_blank" rel="external">https://git-scm.com/downloads</a></p><h3 id="3-安装Hexo"><a href="#3-安装Hexo" class="headerlink" title="3.安装Hexo"></a>3.安装Hexo</h3><p>cmd输入：</p><pre><code class="lang-python">$ npm install -g hexo-cli</code></pre><h2 id="Hexo建站"><a href="#Hexo建站" class="headerlink" title="Hexo建站"></a>Hexo建站</h2><h3 id="1-初始化站点"><a href="#1-初始化站点" class="headerlink" title="1.初始化站点"></a>1.初始化站点</h3><p>Git Bash输入：</p><pre><code class="lang-python">$ hexo init &lt;folder&gt; //folder为自定义的文件夹名$ cd &lt;folder&gt;$ npm install</code></pre><p>初始化完成后,根目录的文件如下：</p><a id="more"></a><ul><li><p>_config.yml<br>博客的配置主文件，网站的主要参数在这里配置，比如网站名称，副标题，描述，作者，语言，主题，部署等等。<br>详细说明见：<a href="https://hexo.io/zh-cn/docs/configuration" target="_blank" rel="external">https://hexo.io/zh-cn/docs/configuration</a></p></li><li><p>package.json<br>记录hexo框架的参数和所依赖插件</p></li><li><p>scaffolds<br>页面模板文件存放目录，新建文章时，Hexo 会根据 scaffold 来建立文件</p></li><li><p>source<br>保存文章的目录，文章是.md文件，Hexo会将_post目录下的.md文件编译成html文件，存放到根目录的public文件夹下</p></li><li><p>themes<br>主题文件存放目录，Hexo中集成了丰富的博客主题，用户可以自己下载并更换</p></li><li><p>public<br>网页文件的存放目录，网页文件是使用命令自动生成的，部署博客时Hexo会将public下的文件上传至GitHub</p></li></ul><h3 id="2-本地访问"><a href="#2-本地访问" class="headerlink" title="2.本地访问"></a>2.本地访问</h3><p>Git Bash输入：</p><pre><code class="lang-python">$ hexo server //使用默认端口4000或者$hexo server -p 5000 //更改端口</code></pre><p>本地浏览器输入：</p><pre><code class="lang-python">http://localhost:4000/</code></pre><h3 id="3-部署到GitHub上"><a href="#3-部署到GitHub上" class="headerlink" title="3.部署到GitHub上"></a>3.部署到GitHub上</h3><p>在Github上new repositories，并且Repository name为[username].github.io，[username]指的是github用户名。修改根目录下的_config.yml配置文件,注意冒号后面必须有一个空格</p><pre><code class="lang-python">deploy:  type: git  repository: https://github.com/[username]/[username].github.io.git   branch: master</code></pre><p>安装部署git的依赖包，根目录下cmd输入：</p><pre><code class="lang-python">npm install hexo-deployer-git --save</code></pre><p>生成页面并部署至GitHub，Git Bash输入：</p><pre><code class="lang-python">hexo generate //hexo ghexo deploy //hexo d</code></pre><p>浏览器访问[username].github.io即可</p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><pre><code class="lang-python">hexo clean //清除缓存hexo g //保存修改，生成文件 hexo s 或 hexo s -p 指定端口//启动本地服务，可进行本地预览 hexo d //发布到远程GitHub</code></pre><p>上述命令是把public文件夹下的网站页面上传至GitHub,我们还可以使用Git命令将项目的所有代码保存到GitHub上：</p><pre><code class="lang-python">git add . //将项目的所有文件添加到仓库中git status //查看更改的内容git commit -m &quot;版本信息&quot; //为更新做注释git pull origin hexo //多人协作时，代码上传github前需要pull远程仓库代码到本地git push origin hexo //上传代码到GitHub远程仓库的hexo分支</code></pre><h2 id="Hexo页面美化"><a href="#Hexo页面美化" class="headerlink" title="Hexo页面美化"></a>Hexo页面美化</h2><h3 id="下载主题"><a href="#下载主题" class="headerlink" title="下载主题"></a>下载主题</h3><p><a href="https://hexo.io/themes/" target="_blank" rel="external">Hexo主题官网</a>中提供了丰富的主题模板，我们可以从中选择自己喜欢的主题进行配置，我的个人博客选择的是<a href="http://theme-next.iissnan.com/" target="_blank" rel="external">NexT主题</a>，安装步骤如下：<br>站点根目录下Git Bash输入如下命令，完成后，在根目录的themes文件夹下会增加一个next的目录，里面存放next主题的相关文件</p><pre><code class="lang-python">$ git clone https://github.com/iissnan/hexo-theme-next themes/next</code></pre><p>在根目录的_config.yml配置文件中启用next主题</p><pre><code class="lang-python">theme: next</code></pre><p>重新部署网站即可生效。可以通过修改next文件夹下的_config.yml来改变next主题样式，如：</p><pre><code class="lang-python">#scheme: Muse#scheme: Mistscheme: Pisces</code></pre><h3 id="给文章添加分类和标签"><a href="#给文章添加分类和标签" class="headerlink" title="给文章添加分类和标签"></a>给文章添加分类和标签</h3><p>创建categories和tags页面</p><pre><code class="lang-python">$ hexo new page categories$ hexo new page tags</code></pre><p>创建完成后，在source文件夹下会增加categories和tags两个文件夹，分别打开这两个文件夹下的index.md修改：</p><pre><code class="lang-python">---title: 文章分类date: 2018-00-00 13:47:40type: &quot;categories&quot;------title: 标签date: 2018-00-00 13:47:40type: &quot;tags&quot;---</code></pre><p>在文章的.md头部属性中增加categories和tags属性：</p><pre><code class="lang-python">---title: FM(Factorization Machine)模型date: 2018-10-18categories:      - 推荐与CTRtags:    - 矩阵分解    - CTR预估---</code></pre><h3 id="给文章插入图片"><a href="#给文章插入图片" class="headerlink" title="给文章插入图片"></a>给文章插入图片</h3><p>安装依赖包：</p><pre><code class="lang-python">npm install hexo-asset-image --save</code></pre><p>source目录下建立images文件夹用于存放图片，文章中插入图片：</p><pre><code class="lang-python">![图片说明文字](图片的相对路径)</code></pre><h3 id="使用LaTex编辑数学公式"><a href="#使用LaTex编辑数学公式" class="headerlink" title="使用LaTex编辑数学公式"></a>使用LaTex编辑数学公式</h3><p>更换依赖包，cmd输入：</p><pre><code class="lang-python">npm uninstall hexo-renderer-marked --savenpm install hexo-renderer-kramed --save</code></pre><p>修改/node_modules/hexo-renderer-kramed/lib/renderer.js：</p><pre><code class="lang-python">// Change inline math rulefunction formatText(text) {    return text;}</code></pre><p>更换依赖包，cmd输入：</p><pre><code class="lang-python">npm uninstall hexo-math --savenpm install hexo-renderer-mathjax --save</code></pre><p>修改Mathjax的配置文件/node_modules/hexo-renderer-mathjax/mathjax.html：</p><pre><code class="lang-python">&lt;!-- &lt;script src=&quot;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot;&gt;&lt;/script&gt; --&gt;&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML&quot;&gt;&lt;/script&gt;</code></pre><p>更改默认转义规则/node_modules\kramed\lib\rules\inline.js：</p><pre><code class="lang-python">//escape: /^\\([\\`*{}\[\]()#$+\-.!_&gt;])/,//em: /^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,escape: /^\\([`*\[\]()# +\-.!_&gt;])/,em: /^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,</code></pre><p>在next目录的_config.yml中开启mathjax</p><pre><code class="lang-python">mathjax:    enable: true</code></pre><p>文章的.md头部属性中增加mathjax属性：</p><pre><code class="lang-python">--- title: FM(Factorization Machine)模型date: 2018-10-18categories:      - 推荐与CTRmathjax: true---</code></pre><h3 id="给文章添加阅读次数"><a href="#给文章添加阅读次数" class="headerlink" title="给文章添加阅读次数"></a>给文章添加阅读次数</h3><p>注册<a href="https://leancloud.cn/" target="_blank" rel="external">LeanClound</a>账号，创建一个应用：<br><img src="/images/1025_pic1.PNG" alt="upload successful"><br>进入应用中创建一个名为Counter的Class:<br><img src="/images/1025_pic2.PNG" alt="upload successful"><br>在next目录的_config.yml中增加：</p><pre><code class="lang-python">leancloud_visitors:  enable: true  app_id:   app_key:</code></pre><p>app_id和app_key的值来源于下图：<br><img src="/images/1025_pic3.PNG" alt="upload successful"></p><h3 id="博客添加站内搜索"><a href="#博客添加站内搜索" class="headerlink" title="博客添加站内搜索"></a>博客添加站内搜索</h3><p>安装站内搜索插件</p><pre><code class="lang-python">$  npm install hexo-generator-searchdb --save</code></pre><p>根目录下的_config.yml添加：</p><pre><code class="lang-python">#表示站内搜索search:    path: search.xml    field: post    format: html    limit: 10000</code></pre><p>next目录下的_config.yml添加：</p><pre><code class="lang-python">local_search:  enable: true  #设置为true  trigger: auto  # auto /  manual，auto 自动搜索、manual：按回车[enter ]键手动搜索  top_n_per_article: 1  unescape: true</code></pre>]]></content>
      
      
      <categories>
          
          <category> Hexo配置 </category>
          
      </categories>
      
      
    </entry>
    
  
  
</search>
